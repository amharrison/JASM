/**
 * generated by Xtext 2.19.0
 */
package mil.navy.nrl.ncarai.jasm.ui.quickfix;

import java.util.HashMap;
import javax.inject.Inject;
import mil.navy.nrl.ncarai.jasm.program.BufferPattern;
import mil.navy.nrl.ncarai.jasm.program.Function;
import mil.navy.nrl.ncarai.jasm.program.PackageDef;
import mil.navy.nrl.ncarai.jasm.program.Pattern;
import mil.navy.nrl.ncarai.jasm.program.ProgramFactory;
import mil.navy.nrl.ncarai.jasm.validation.ValidationUtilities;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.diagnostics.Diagnostic;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext;
import org.eclipse.xtext.ui.editor.model.edit.ISemanticModification;
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider;
import org.eclipse.xtext.ui.editor.quickfix.Fix;
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor;
import org.eclipse.xtext.validation.Issue;
import org.eclipse.xtext.xbase.lib.Extension;
import org.jactr.io2.jactr.modelFragment.Buffer;
import org.jactr.io2.jactr.modelFragment.ChunkType;

/**
 * Custom quickfixes.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
@SuppressWarnings("all")
public class ProgramQuickfixProvider extends DefaultQuickfixProvider {
  @Inject
  @Extension
  private ValidationUtilities _validationUtilities;
  
  @Fix(Diagnostic.LINKING_DIAGNOSTIC)
  public void createPatternIssue(final Issue issue, final IssueResolutionAcceptor acceptor) {
    int _indexOf = issue.getMessage().indexOf("Pattern");
    boolean _notEquals = (_indexOf != (-1));
    if (_notEquals) {
      final ISemanticModification _function = (EObject element, IModificationContext context) -> {
        final IXtextDocument doc = context.getXtextDocument();
        final String badName = doc.get((issue.getOffset()).intValue(), (issue.getLength()).intValue());
        final Pattern newPattern = ProgramFactory.eINSTANCE.createPattern();
        newPattern.setName(badName);
        final Function function = EcoreUtil2.<Function>getContainerOfType(element, Function.class);
        final BufferPattern bufferPattern = EcoreUtil2.<BufferPattern>getContainerOfType(element, BufferPattern.class);
        if ((bufferPattern != null)) {
          final HashMap<Buffer, ChunkType> contents = this._validationUtilities.inferBufferContents(element);
          final ChunkType chunkType = contents.get(bufferPattern.getBuffer());
          if ((chunkType != null)) {
            newPattern.setType(chunkType.getName());
          } else {
            newPattern.setType(function.getName());
          }
        } else {
          newPattern.setType(function.getName());
        }
        EcoreUtil2.<PackageDef>getContainerOfType(function, PackageDef.class).getPatterns().add(newPattern);
      };
      acceptor.accept(issue, "Create missing pattern", "Create missing pattern", null, _function);
    }
  }
}
