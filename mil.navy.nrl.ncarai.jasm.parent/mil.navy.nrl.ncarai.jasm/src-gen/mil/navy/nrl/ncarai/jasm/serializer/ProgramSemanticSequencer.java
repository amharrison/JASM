/*
 * generated by Xtext 2.20.0
 */
package mil.navy.nrl.ncarai.jasm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mil.navy.nrl.ncarai.jasm.program.AsStatement;
import mil.navy.nrl.ncarai.jasm.program.AssignmentStatement;
import mil.navy.nrl.ncarai.jasm.program.Bindings;
import mil.navy.nrl.ncarai.jasm.program.Block;
import mil.navy.nrl.ncarai.jasm.program.BufferDef;
import mil.navy.nrl.ncarai.jasm.program.BufferPattern;
import mil.navy.nrl.ncarai.jasm.program.CaseStatement;
import mil.navy.nrl.ncarai.jasm.program.DoWhileStatement;
import mil.navy.nrl.ncarai.jasm.program.ForLoopStatement;
import mil.navy.nrl.ncarai.jasm.program.Function;
import mil.navy.nrl.ncarai.jasm.program.FunctionCallStatement;
import mil.navy.nrl.ncarai.jasm.program.GeneratorDef;
import mil.navy.nrl.ncarai.jasm.program.Handler;
import mil.navy.nrl.ncarai.jasm.program.IfThenElseStatement;
import mil.navy.nrl.ncarai.jasm.program.Include;
import mil.navy.nrl.ncarai.jasm.program.InsertionStatement;
import mil.navy.nrl.ncarai.jasm.program.Mapping;
import mil.navy.nrl.ncarai.jasm.program.MatchStatement;
import mil.navy.nrl.ncarai.jasm.program.OutputStatement;
import mil.navy.nrl.ncarai.jasm.program.PackageDef;
import mil.navy.nrl.ncarai.jasm.program.Pattern;
import mil.navy.nrl.ncarai.jasm.program.Program;
import mil.navy.nrl.ncarai.jasm.program.ProgramPackage;
import mil.navy.nrl.ncarai.jasm.program.RemoveStatement;
import mil.navy.nrl.ncarai.jasm.program.Repeat;
import mil.navy.nrl.ncarai.jasm.program.RepeatUntilStatement;
import mil.navy.nrl.ncarai.jasm.program.RequestDef;
import mil.navy.nrl.ncarai.jasm.program.RequestStatement;
import mil.navy.nrl.ncarai.jasm.program.RetainAsStatement;
import mil.navy.nrl.ncarai.jasm.program.ReturnStatement;
import mil.navy.nrl.ncarai.jasm.program.ReturnVariableReference;
import mil.navy.nrl.ncarai.jasm.program.RewardStatement;
import mil.navy.nrl.ncarai.jasm.program.Until;
import mil.navy.nrl.ncarai.jasm.program.UntilRepeatStatement;
import mil.navy.nrl.ncarai.jasm.program.VariableReference;
import mil.navy.nrl.ncarai.jasm.program.VariableStatement;
import mil.navy.nrl.ncarai.jasm.program.VariableValue;
import mil.navy.nrl.ncarai.jasm.program.While;
import mil.navy.nrl.ncarai.jasm.program.WhileDoStatement;
import mil.navy.nrl.ncarai.jasm.program.WithAsStatement;
import mil.navy.nrl.ncarai.jasm.services.ProgramGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.jactr.io2.jactr.modelFragment.Add;
import org.jactr.io2.jactr.modelFragment.AndSlot;
import org.jactr.io2.jactr.modelFragment.Buffer;
import org.jactr.io2.jactr.modelFragment.Buffers;
import org.jactr.io2.jactr.modelFragment.ChunkDef;
import org.jactr.io2.jactr.modelFragment.ChunkType;
import org.jactr.io2.jactr.modelFragment.Chunks;
import org.jactr.io2.jactr.modelFragment.ConditionalSlot;
import org.jactr.io2.jactr.modelFragment.Import;
import org.jactr.io2.jactr.modelFragment.IsaBlock;
import org.jactr.io2.jactr.modelFragment.Match;
import org.jactr.io2.jactr.modelFragment.ModelExtension;
import org.jactr.io2.jactr.modelFragment.ModelFragment;
import org.jactr.io2.jactr.modelFragment.ModelFragmentPackage;
import org.jactr.io2.jactr.modelFragment.ModelModule;
import org.jactr.io2.jactr.modelFragment.Modify;
import org.jactr.io2.jactr.modelFragment.NotSlot;
import org.jactr.io2.jactr.modelFragment.OrSlot;
import org.jactr.io2.jactr.modelFragment.Output;
import org.jactr.io2.jactr.modelFragment.PackageDeclaration;
import org.jactr.io2.jactr.modelFragment.Parameters;
import org.jactr.io2.jactr.modelFragment.ParametersBlock;
import org.jactr.io2.jactr.modelFragment.Production;
import org.jactr.io2.jactr.modelFragment.Proxy;
import org.jactr.io2.jactr.modelFragment.Query;
import org.jactr.io2.jactr.modelFragment.Remove;
import org.jactr.io2.jactr.modelFragment.Script;
import org.jactr.io2.jactr.modelFragment.SimpleSlot;
import org.jactr.io2.jactr.modelFragment.Value;
import org.jactr.io2.jactr.serializer.ModelFragmentSemanticSequencer;

@SuppressWarnings("all")
public class ProgramSemanticSequencer extends ModelFragmentSemanticSequencer {

	@Inject
	private ProgramGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModelFragmentPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelFragmentPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case ModelFragmentPackage.AND_SLOT:
				sequence_AndSlot(context, (AndSlot) semanticObject); 
				return; 
			case ModelFragmentPackage.BUFFER:
				sequence_Buffer_Overridable(context, (Buffer) semanticObject); 
				return; 
			case ModelFragmentPackage.BUFFERS:
				sequence_Buffers(context, (Buffers) semanticObject); 
				return; 
			case ModelFragmentPackage.CHUNK_DEF:
				sequence_ChunkDef_Overridable(context, (ChunkDef) semanticObject); 
				return; 
			case ModelFragmentPackage.CHUNK_TYPE:
				sequence_ChunkType_Overridable(context, (ChunkType) semanticObject); 
				return; 
			case ModelFragmentPackage.CHUNKS:
				sequence_Chunks(context, (Chunks) semanticObject); 
				return; 
			case ModelFragmentPackage.CONDITIONAL_SLOT:
				sequence_ConditionalSlot(context, (ConditionalSlot) semanticObject); 
				return; 
			case ModelFragmentPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ModelFragmentPackage.ISA_BLOCK:
				sequence_IsaBlock(context, (IsaBlock) semanticObject); 
				return; 
			case ModelFragmentPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case ModelFragmentPackage.MODEL_EXTENSION:
				sequence_ModelExtension(context, (ModelExtension) semanticObject); 
				return; 
			case ModelFragmentPackage.MODEL_FRAGMENT:
				sequence_ModelFragment(context, (ModelFragment) semanticObject); 
				return; 
			case ModelFragmentPackage.MODEL_MODULE:
				sequence_ModelModule(context, (ModelModule) semanticObject); 
				return; 
			case ModelFragmentPackage.MODIFY:
				sequence_SimpleSlotBlock(context, (Modify) semanticObject); 
				return; 
			case ModelFragmentPackage.NOT_SLOT:
				sequence_NotSlot(context, (NotSlot) semanticObject); 
				return; 
			case ModelFragmentPackage.OR_SLOT:
				sequence_OrSlot(context, (OrSlot) semanticObject); 
				return; 
			case ModelFragmentPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case ModelFragmentPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case ModelFragmentPackage.PARAMETER:
				sequence_Parameter(context, (org.jactr.io2.jactr.modelFragment.Parameter) semanticObject); 
				return; 
			case ModelFragmentPackage.PARAMETERS:
				sequence_Parameters(context, (Parameters) semanticObject); 
				return; 
			case ModelFragmentPackage.PARAMETERS_BLOCK:
				sequence_ParametersBlock(context, (ParametersBlock) semanticObject); 
				return; 
			case ModelFragmentPackage.PRODUCTION:
				sequence_Overridable_Production(context, (Production) semanticObject); 
				return; 
			case ModelFragmentPackage.PROXY:
				sequence_Proxy(context, (Proxy) semanticObject); 
				return; 
			case ModelFragmentPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case ModelFragmentPackage.REMOVE:
				sequence_SimpleSlotBlock(context, (Remove) semanticObject); 
				return; 
			case ModelFragmentPackage.SCRIPT:
				sequence_Script(context, (Script) semanticObject); 
				return; 
			case ModelFragmentPackage.SIMPLE_SLOT:
				sequence_SimpleSlot(context, (SimpleSlot) semanticObject); 
				return; 
			case ModelFragmentPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		else if (epackage == ProgramPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ProgramPackage.AS_STATEMENT:
				sequence_AsStatement(context, (AsStatement) semanticObject); 
				return; 
			case ProgramPackage.ASSIGNMENT_STATEMENT:
				sequence_AssignmentStatement(context, (AssignmentStatement) semanticObject); 
				return; 
			case ProgramPackage.BINDINGS:
				sequence_Bindings(context, (Bindings) semanticObject); 
				return; 
			case ProgramPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case ProgramPackage.BUFFER_DEF:
				sequence_BufferDef(context, (BufferDef) semanticObject); 
				return; 
			case ProgramPackage.BUFFER_PATTERN:
				sequence_BufferPattern(context, (BufferPattern) semanticObject); 
				return; 
			case ProgramPackage.CASE_STATEMENT:
				sequence_CaseStatement(context, (CaseStatement) semanticObject); 
				return; 
			case ProgramPackage.DO_WHILE_STATEMENT:
				sequence_DoWhileStatement(context, (DoWhileStatement) semanticObject); 
				return; 
			case ProgramPackage.FOR_LOOP_STATEMENT:
				sequence_ForLoopStatement(context, (ForLoopStatement) semanticObject); 
				return; 
			case ProgramPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case ProgramPackage.FUNCTION_CALL_STATEMENT:
				sequence_FunctionCallStatement(context, (FunctionCallStatement) semanticObject); 
				return; 
			case ProgramPackage.GENERATOR_DEF:
				sequence_GeneratorDef(context, (GeneratorDef) semanticObject); 
				return; 
			case ProgramPackage.HANDLER:
				sequence_Handler(context, (Handler) semanticObject); 
				return; 
			case ProgramPackage.IF_THEN_ELSE_STATEMENT:
				sequence_IfThenElseStatement(context, (IfThenElseStatement) semanticObject); 
				return; 
			case ProgramPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case ProgramPackage.INSERTION_STATEMENT:
				sequence_InsertionStatement(context, (InsertionStatement) semanticObject); 
				return; 
			case ProgramPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case ProgramPackage.MATCH_STATEMENT:
				sequence_MatchStatement(context, (MatchStatement) semanticObject); 
				return; 
			case ProgramPackage.OUTPUT_STATEMENT:
				sequence_OutputStatement(context, (OutputStatement) semanticObject); 
				return; 
			case ProgramPackage.PACKAGE_DEF:
				sequence_PackageDef(context, (PackageDef) semanticObject); 
				return; 
			case ProgramPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case ProgramPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case ProgramPackage.REMOVE_STATEMENT:
				sequence_RemoveStatement(context, (RemoveStatement) semanticObject); 
				return; 
			case ProgramPackage.REPEAT:
				sequence_Repeat(context, (Repeat) semanticObject); 
				return; 
			case ProgramPackage.REPEAT_UNTIL_STATEMENT:
				sequence_RepeatUntilStatement(context, (RepeatUntilStatement) semanticObject); 
				return; 
			case ProgramPackage.REQUEST_DEF:
				sequence_RequestDef(context, (RequestDef) semanticObject); 
				return; 
			case ProgramPackage.REQUEST_STATEMENT:
				sequence_RequestStatement(context, (RequestStatement) semanticObject); 
				return; 
			case ProgramPackage.RETAIN_AS_STATEMENT:
				sequence_RetainAsStatement(context, (RetainAsStatement) semanticObject); 
				return; 
			case ProgramPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case ProgramPackage.RETURN_VARIABLE_REFERENCE:
				sequence_ReturnVariableReference(context, (ReturnVariableReference) semanticObject); 
				return; 
			case ProgramPackage.REWARD_STATEMENT:
				sequence_RewardStatement(context, (RewardStatement) semanticObject); 
				return; 
			case ProgramPackage.UNTIL:
				sequence_Until(context, (Until) semanticObject); 
				return; 
			case ProgramPackage.UNTIL_REPEAT_STATEMENT:
				sequence_UntilRepeatStatement(context, (UntilRepeatStatement) semanticObject); 
				return; 
			case ProgramPackage.VARIABLE_REFERENCE:
				sequence_VariableReference(context, (VariableReference) semanticObject); 
				return; 
			case ProgramPackage.VARIABLE_STATEMENT:
				sequence_VariableStatement(context, (VariableStatement) semanticObject); 
				return; 
			case ProgramPackage.VARIABLE_VALUE:
				sequence_VariableValue(context, (VariableValue) semanticObject); 
				return; 
			case ProgramPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			case ProgramPackage.WHILE_DO_STATEMENT:
				sequence_WhileDoStatement(context, (WhileDoStatement) semanticObject); 
				return; 
			case ProgramPackage.WITH_AS_STATEMENT:
				sequence_WithAsStatement(context, (WithAsStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AsStatement returns AsStatement
	 *
	 * Constraint:
	 *     (buffer=[Buffer|ID] type=ID)
	 */
	protected void sequence_AsStatement(ISerializationContext context, AsStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.AS_STATEMENT__BUFFER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.AS_STATEMENT__BUFFER));
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.AS_STATEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.AS_STATEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsStatementAccess().getBufferBufferIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ProgramPackage.Literals.AS_STATEMENT__BUFFER, false));
		feeder.accept(grammarAccess.getAsStatementAccess().getTypeIDTerminalRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns AssignmentStatement
	 *     AssignmentStatement returns AssignmentStatement
	 *
	 * Constraint:
	 *     (reference=VariableReference assignment=VariableValue)
	 */
	protected void sequence_AssignmentStatement(ISerializationContext context, AssignmentStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.ASSIGNMENT_STATEMENT__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.ASSIGNMENT_STATEMENT__REFERENCE));
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.ASSIGNMENT_STATEMENT__ASSIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.ASSIGNMENT_STATEMENT__ASSIGNMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getReferenceVariableReferenceParserRuleCall_0_0(), semanticObject.getReference());
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getAssignmentVariableValueParserRuleCall_2_0(), semanticObject.getAssignment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Bindings returns Bindings
	 *
	 * Constraint:
	 *     (bindings+=BufferPattern bindings+=BufferPattern*)
	 */
	protected void sequence_Bindings(ISerializationContext context, Bindings semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     instructions+=Instruction+
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BufferDef returns BufferDef
	 *
	 * Constraint:
	 *     (name=ID (readable?='readable' | writable?='writable')? error?='error'? requests+=RequestDef requests+=RequestDef*)
	 */
	protected void sequence_BufferDef(ISerializationContext context, BufferDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BufferPattern returns BufferPattern
	 *
	 * Constraint:
	 *     (buffer=[Buffer|ID] pattern=[Pattern|ID]?)
	 */
	protected void sequence_BufferPattern(ISerializationContext context, BufferPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseStatement returns CaseStatement
	 *
	 * Constraint:
	 *     (bindings=Bindings priority=NUMERIC? block=Block)
	 */
	protected void sequence_CaseStatement(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns DoWhileStatement
	 *     DoWhileStatement returns DoWhileStatement
	 *
	 * Constraint:
	 *     (block=Block while=While)
	 */
	protected void sequence_DoWhileStatement(ISerializationContext context, DoWhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.DO_WHILE_STATEMENT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.DO_WHILE_STATEMENT__BLOCK));
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.DO_WHILE_STATEMENT__WHILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.DO_WHILE_STATEMENT__WHILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoWhileStatementAccess().getBlockBlockParserRuleCall_1_0(), semanticObject.getBlock());
		feeder.accept(grammarAccess.getDoWhileStatementAccess().getWhileWhileParserRuleCall_2_0(), semanticObject.getWhile());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns ForLoopStatement
	 *     ForLoopStatement returns ForLoopStatement
	 *
	 * Constraint:
	 *     (
	 *         forced?='force'? 
	 *         forBuffer=[Buffer|ID] 
	 *         initial=[Pattern|ID] 
	 *         initialBindings=Bindings 
	 *         subsequent=[Pattern|ID] 
	 *         subsequentBindings=Bindings 
	 *         block=Block
	 *     )
	 */
	protected void sequence_ForLoopStatement(ISerializationContext context, ForLoopStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns FunctionCallStatement
	 *     FunctionCallStatement returns FunctionCallStatement
	 *
	 * Constraint:
	 *     (function=[Function|ID] (parameters+=AssignmentStatement parameters+=AssignmentStatement*)?)
	 */
	protected void sequence_FunctionCallStatement(ISerializationContext context, FunctionCallStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         (void?='void' | chunk?='element') 
	 *         name=ID 
	 *         (slots+=VariableStatement slots+=VariableStatement*)? 
	 *         assumedContents=WithAsStatement? 
	 *         retainedContents=RetainAsStatement? 
	 *         variables+=VariableStatement* 
	 *         instructions+=Instruction+
	 *     )
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorDef returns GeneratorDef
	 *
	 * Constraint:
	 *     parameters=ParametersBlock
	 */
	protected void sequence_GeneratorDef(ISerializationContext context, GeneratorDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.GENERATOR_DEF__PARAMETERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.GENERATOR_DEF__PARAMETERS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneratorDefAccess().getParametersParametersBlockParserRuleCall_1_0(), semanticObject.getParameters());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Handler returns Handler
	 *
	 * Constraint:
	 *     block=Block
	 */
	protected void sequence_Handler(ISerializationContext context, Handler semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.HANDLER__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.HANDLER__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHandlerAccess().getBlockBlockParserRuleCall_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns IfThenElseStatement
	 *     IfThenElseStatement returns IfThenElseStatement
	 *
	 * Constraint:
	 *     (bindings=Bindings thenBlock=Block elseBlock=Block?)
	 */
	protected void sequence_IfThenElseStatement(ISerializationContext context, IfThenElseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Include returns Include
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.INCLUDE__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.INCLUDE__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InsertionStatement returns InsertionStatement
	 *     Instruction returns InsertionStatement
	 *
	 * Constraint:
	 *     (entryState=ID exitState=ID shouldGenerate?='generate'?)
	 */
	protected void sequence_InsertionStatement(ISerializationContext context, InsertionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     assignments+=AssignmentStatement+
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns MatchStatement
	 *     MatchStatement returns MatchStatement
	 *
	 * Constraint:
	 *     (cases+=CaseStatement cases+=CaseStatement* defaultBlock=Block)
	 */
	protected void sequence_MatchStatement(ISerializationContext context, MatchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns OutputStatement
	 *     OutputStatement returns OutputStatement
	 *
	 * Constraint:
	 *     (string=STRING bindings=Bindings?)
	 */
	protected void sequence_OutputStatement(ISerializationContext context, OutputStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageDef returns PackageDef
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         target=QualifiedName 
	 *         (imports+=Import | includes+=Include)* 
	 *         generator=GeneratorDef? 
	 *         bufferDefs+=BufferDef* 
	 *         chunkTypes+=ChunkType? 
	 *         ((chunkDefs+=Chunks | patterns+=Pattern | functions+=Function)? chunkTypes+=ChunkType?)*
	 *     )
	 */
	protected void sequence_PackageDef(ISerializationContext context, PackageDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (name=ID type=ID? slots+=ConditionalSlot*)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     package=PackageDef
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.PROGRAM__PACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.PROGRAM__PACKAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getPackagePackageDefParserRuleCall_0(), semanticObject.getPackage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns RemoveStatement
	 *     RemoveStatement returns RemoveStatement
	 *
	 * Constraint:
	 *     (buffers+=[Buffer|ID] buffers+=[Buffer|ID]*)
	 */
	protected void sequence_RemoveStatement(ISerializationContext context, RemoveStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns RepeatUntilStatement
	 *     RepeatUntilStatement returns RepeatUntilStatement
	 *
	 * Constraint:
	 *     (repeat=Repeat until=Until)
	 */
	protected void sequence_RepeatUntilStatement(ISerializationContext context, RepeatUntilStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.REPEAT_UNTIL_STATEMENT__REPEAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.REPEAT_UNTIL_STATEMENT__REPEAT));
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.REPEAT_UNTIL_STATEMENT__UNTIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.REPEAT_UNTIL_STATEMENT__UNTIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatUntilStatementAccess().getRepeatRepeatParserRuleCall_0_0(), semanticObject.getRepeat());
		feeder.accept(grammarAccess.getRepeatUntilStatementAccess().getUntilUntilParserRuleCall_1_0(), semanticObject.getUntil());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Repeat returns Repeat
	 *
	 * Constraint:
	 *     block=Block
	 */
	protected void sequence_Repeat(ISerializationContext context, Repeat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.REPEAT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.REPEAT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatAccess().getBlockBlockParserRuleCall_1_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RequestDef returns RequestDef
	 *
	 * Constraint:
	 *     ((wildcardRequest?='*' | requestType=[ChunkType|ID]) (wildcardResult?='*' | resultType=[ChunkType|ID])?)
	 */
	protected void sequence_RequestDef(ISerializationContext context, RequestDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns RequestStatement
	 *     RequestStatement returns RequestStatement
	 *
	 * Constraint:
	 *     (
	 *         forced?='force'? 
	 *         buffer=[Buffer|ID] 
	 *         patternReference=VariableReference? 
	 *         bindings=Bindings? 
	 *         cast=ID? 
	 *         mapping=Mapping? 
	 *         handler=Handler?
	 *     )
	 */
	protected void sequence_RequestStatement(ISerializationContext context, RequestStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RetainAsStatement returns RetainAsStatement
	 *
	 * Constraint:
	 *     (retained+=AsStatement retained+=AsStatement*)
	 */
	protected void sequence_RetainAsStatement(ISerializationContext context, RetainAsStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     reference=ReturnVariableReference?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnVariableReference returns ReturnVariableReference
	 *
	 * Constraint:
	 *     (buffer=[Buffer|ID]? value=Value)
	 */
	protected void sequence_ReturnVariableReference(ISerializationContext context, ReturnVariableReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns RewardStatement
	 *     RewardStatement returns RewardStatement
	 *
	 * Constraint:
	 *     reward=NUMERIC
	 */
	protected void sequence_RewardStatement(ISerializationContext context, RewardStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.REWARD_STATEMENT__REWARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.REWARD_STATEMENT__REWARD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRewardStatementAccess().getRewardNUMERICParserRuleCall_1_0(), semanticObject.getReward());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns UntilRepeatStatement
	 *     UntilRepeatStatement returns UntilRepeatStatement
	 *
	 * Constraint:
	 *     (until=Until block=Block)
	 */
	protected void sequence_UntilRepeatStatement(ISerializationContext context, UntilRepeatStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.UNTIL_REPEAT_STATEMENT__UNTIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.UNTIL_REPEAT_STATEMENT__UNTIL));
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.UNTIL_REPEAT_STATEMENT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.UNTIL_REPEAT_STATEMENT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUntilRepeatStatementAccess().getUntilUntilParserRuleCall_0_0(), semanticObject.getUntil());
		feeder.accept(grammarAccess.getUntilRepeatStatementAccess().getBlockBlockParserRuleCall_1_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Until returns Until
	 *
	 * Constraint:
	 *     bindings=Bindings
	 */
	protected void sequence_Until(ISerializationContext context, Until semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.UNTIL__BINDINGS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.UNTIL__BINDINGS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUntilAccess().getBindingsBindingsParserRuleCall_2_0(), semanticObject.getBindings());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableReference returns VariableReference
	 *
	 * Constraint:
	 *     (buffer=[Buffer|ID]? name=ID)
	 */
	protected void sequence_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableStatement returns VariableStatement
	 *
	 * Constraint:
	 *     assignment=AssignmentStatement
	 */
	protected void sequence_VariableStatement(ISerializationContext context, VariableStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.VARIABLE_STATEMENT__ASSIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.VARIABLE_STATEMENT__ASSIGNMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableStatementAccess().getAssignmentAssignmentStatementParserRuleCall_1_0(), semanticObject.getAssignment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableValue returns VariableValue
	 *
	 * Constraint:
	 *     ((buffer=[Buffer|ID]? value=Value) | functionCall=FunctionCallStatement)
	 */
	protected void sequence_VariableValue(ISerializationContext context, VariableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns WhileDoStatement
	 *     WhileDoStatement returns WhileDoStatement
	 *
	 * Constraint:
	 *     (while=While block=Block)
	 */
	protected void sequence_WhileDoStatement(ISerializationContext context, WhileDoStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.WHILE_DO_STATEMENT__WHILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.WHILE_DO_STATEMENT__WHILE));
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.WHILE_DO_STATEMENT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.WHILE_DO_STATEMENT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileDoStatementAccess().getWhileWhileParserRuleCall_0_0(), semanticObject.getWhile());
		feeder.accept(grammarAccess.getWhileDoStatementAccess().getBlockBlockParserRuleCall_1_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     While returns While
	 *
	 * Constraint:
	 *     bindings=Bindings
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProgramPackage.Literals.WHILE__BINDINGS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProgramPackage.Literals.WHILE__BINDINGS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileAccess().getBindingsBindingsParserRuleCall_2_0(), semanticObject.getBindings());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WithAsStatement returns WithAsStatement
	 *
	 * Constraint:
	 *     (assumed+=AsStatement assumed+=AsStatement*)
	 */
	protected void sequence_WithAsStatement(ISerializationContext context, WithAsStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
