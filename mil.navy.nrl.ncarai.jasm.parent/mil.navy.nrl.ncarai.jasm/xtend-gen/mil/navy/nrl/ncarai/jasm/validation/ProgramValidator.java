/**
 * generated by Xtext 2.19.0
 */
package mil.navy.nrl.ncarai.jasm.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedListMultimap;
import com.google.common.collect.Sets;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Consumer;
import javax.inject.Inject;
import mil.navy.nrl.ncarai.jasm.program.AsStatement;
import mil.navy.nrl.ncarai.jasm.program.AssignmentStatement;
import mil.navy.nrl.ncarai.jasm.program.Bindings;
import mil.navy.nrl.ncarai.jasm.program.BufferDef;
import mil.navy.nrl.ncarai.jasm.program.BufferPattern;
import mil.navy.nrl.ncarai.jasm.program.CaseStatement;
import mil.navy.nrl.ncarai.jasm.program.DoWhileStatement;
import mil.navy.nrl.ncarai.jasm.program.ForLoopStatement;
import mil.navy.nrl.ncarai.jasm.program.Function;
import mil.navy.nrl.ncarai.jasm.program.FunctionCallStatement;
import mil.navy.nrl.ncarai.jasm.program.Handler;
import mil.navy.nrl.ncarai.jasm.program.IfThenElseStatement;
import mil.navy.nrl.ncarai.jasm.program.Include;
import mil.navy.nrl.ncarai.jasm.program.Mapping;
import mil.navy.nrl.ncarai.jasm.program.MatchStatement;
import mil.navy.nrl.ncarai.jasm.program.Pattern;
import mil.navy.nrl.ncarai.jasm.program.ProgramPackage;
import mil.navy.nrl.ncarai.jasm.program.RemoveStatement;
import mil.navy.nrl.ncarai.jasm.program.RepeatUntilStatement;
import mil.navy.nrl.ncarai.jasm.program.RequestDef;
import mil.navy.nrl.ncarai.jasm.program.RequestStatement;
import mil.navy.nrl.ncarai.jasm.program.RetainAsStatement;
import mil.navy.nrl.ncarai.jasm.program.ReturnStatement;
import mil.navy.nrl.ncarai.jasm.program.UntilRepeatStatement;
import mil.navy.nrl.ncarai.jasm.program.VariableReference;
import mil.navy.nrl.ncarai.jasm.program.VariableStatement;
import mil.navy.nrl.ncarai.jasm.program.WhileDoStatement;
import mil.navy.nrl.ncarai.jasm.validation.AbstractProgramValidator;
import mil.navy.nrl.ncarai.jasm.validation.ValidationUtilities;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.diagnostics.Diagnostic;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.jactr.io2.jactr.modelFragment.Buffer;
import org.jactr.io2.jactr.modelFragment.ChunkType;
import org.jactr.io2.jactr.modelFragment.Chunks;
import org.jactr.io2.jactr.modelFragment.ConditionalSlot;
import org.jactr.io2.jactr.modelFragment.ModelFragmentPackage;
import org.jactr.io2.jactr.modelFragment.SimpleSlot;
import org.jactr.io2.jactr.modelFragment.Value;
import org.jactr.io2.jactr.validation.IClassNameValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ProgramValidator extends AbstractProgramValidator {
  @Inject
  @Extension
  private ValidationUtilities _validationUtilities;
  
  @Inject
  private IClassNameValidator _classNameValidator;
  
  /**
   * does one of the buffer patterns bind the variable name
   */
  protected boolean defines(final String variableName, final Collection<? extends BufferPattern> bindings) {
    for (final BufferPattern bPattern : bindings) {
      String _name = bPattern.getBuffer().getName();
      String _plus = ("=" + _name);
      boolean _equals = variableName.equals(_plus);
      if (_equals) {
        return true;
      } else {
        final Function1<ConditionalSlot, Boolean> _function = (ConditionalSlot cSlot) -> {
          return Boolean.valueOf(variableName.equals(cSlot.getValue().getName()));
        };
        ConditionalSlot _last = IterableExtensions.<ConditionalSlot>last(IterableExtensions.<ConditionalSlot>filter(bPattern.getPattern().getSlots(), _function));
        boolean _tripleNotEquals = (_last != null);
        if (_tripleNotEquals) {
          return true;
        }
      }
    }
    return false;
  }
  
  @Check(CheckType.NORMAL)
  public void checkIncludesOnClasspath(final Include includeDef) {
    String _importedNamespace = includeDef.getImportedNamespace();
    int _length = includeDef.getImportedNamespace().length();
    int _minus = (_length - 2);
    String _replace = _importedNamespace.substring(0, _minus).replace(".", 
      "/");
    String altResource = (_replace + ".jasm");
    boolean _canResolve = this._classNameValidator.canResolve(includeDef.eResource(), altResource);
    boolean _not = (!_canResolve);
    if (_not) {
      this.error((("Could not find " + altResource) + " in classpath"), includeDef, 
        ProgramPackage.Literals.INCLUDE__IMPORTED_NAMESPACE);
    }
  }
  
  /**
   * check that each variable in pattern is defined in at least one of the buffer patterns. OR, the variable
   * is used more than once in the pattern
   */
  protected void checkVariablesInPattern(final Pattern pattern, final Collection<? extends BufferPattern> bindings, final EReference errorLiteral) {
    final Function1<ConditionalSlot, Boolean> _function = (ConditionalSlot cSlot) -> {
      return Boolean.valueOf(((cSlot.getValue().getName() != null) && cSlot.getValue().getName().startsWith("=")));
    };
    final Consumer<ConditionalSlot> _function_1 = (ConditionalSlot cSlot) -> {
      final Function1<ConditionalSlot, Boolean> _function_2 = (ConditionalSlot slot) -> {
        return Boolean.valueOf(((slot != cSlot) && Objects.equal(cSlot.getValue().getName(), slot.getValue().getName())));
      };
      final ConditionalSlot anotherDef = IterableExtensions.<ConditionalSlot>findFirst(pattern.getSlots(), _function_2);
      if (((!this.defines(cSlot.getValue().getName(), bindings)) && (anotherDef == null))) {
        String _name = pattern.getName();
        String _plus = ("Pattern " + _name);
        String _plus_1 = (_plus + " references variable ");
        String _name_1 = cSlot.getValue().getName();
        String _plus_2 = (_plus_1 + _name_1);
        String _plus_3 = (_plus_2 + 
          " but it was not bound by binding patterns");
        this.error(_plus_3, errorLiteral);
      }
    };
    IterableExtensions.<ConditionalSlot>filter(pattern.getSlots(), _function).forEach(_function_1);
  }
  
  /**
   * make sure the function return type and the return statement are consistent. Validate
   * the return value/slots
   */
  @Check(CheckType.NORMAL)
  public void checkReturn(final ReturnStatement returnStatement) {
    Value _value = returnStatement.getReference().getValue();
    final boolean returnSupplied = (_value != null);
    final Function function = EcoreUtil2.<Function>getContainerOfType(returnStatement, Function.class);
    if (((function.isVoid() && returnSupplied) || (function.isChunk() && (!returnSupplied)))) {
      this.error("Function and return are inconsistent", ProgramPackage.Literals.RETURN_STATEMENT__REFERENCE);
    }
    boolean _isVoid = function.isVoid();
    if (_isVoid) {
      return;
    }
    Set slotsOf = ((Set) null);
    if ((((returnStatement.getReference() != null) && (returnStatement.getReference().getValue() != null)) && 
      (returnStatement.getReference().getValue().getName() != null))) {
      final String name = returnStatement.getReference().getValue().getName();
      boolean _equals = name.equals("null");
      if (_equals) {
        return;
      }
      if (((returnStatement.getReference().getBuffer() == null) || Objects.equal(returnStatement.getReference().getBuffer().getName(), "goal"))) {
        final Function func = IterableExtensions.<Function>last(Iterables.<Function>filter(EcoreUtil2.getAllContainers(returnStatement), Function.class));
        slotsOf = this._validationUtilities.slotsOf(func);
        boolean _contains = slotsOf.contains(name);
        boolean _not = (!_contains);
        if (_not) {
          boolean _isBuffer = this._validationUtilities.isBuffer(name, returnStatement);
          boolean _not_1 = (!_isBuffer);
          if (_not_1) {
            boolean _isChunkType = this._validationUtilities.isChunkType(name, returnStatement);
            boolean _not_2 = (!_isChunkType);
            if (_not_2) {
              boolean _isChunk = this._validationUtilities.isChunk(name, returnStatement);
              boolean _not_3 = (!_isChunk);
              if (_not_3) {
                this.error(("Unknown chunk " + name), ProgramPackage.Literals.RETURN_STATEMENT__REFERENCE);
              }
            }
          }
        }
      } else {
        final HashMap<Buffer, ChunkType> bufferContents = this._validationUtilities.inferBufferContents(returnStatement);
        final ChunkType chunkType = bufferContents.get(returnStatement.getReference().getBuffer());
        if ((chunkType == null)) {
          this.error(("Could not infer chunktype to validate slot " + name), 
            ProgramPackage.Literals.RETURN_STATEMENT__REFERENCE);
          return;
        }
        slotsOf = this._validationUtilities.slotsOf(chunkType);
        boolean _contains_1 = slotsOf.contains(name);
        boolean _not_4 = (!_contains_1);
        if (_not_4) {
          String _name = chunkType.getName();
          String _plus = ((name + " is an unknown slot for ") + _name);
          String _plus_1 = (_plus + " known: ");
          String _plus_2 = (_plus_1 + slotsOf);
          this.error(_plus_2, 
            ProgramPackage.Literals.RETURN_STATEMENT__REFERENCE);
        }
      }
    }
  }
  
  /**
   * verify that function has an unambiguous exit point
   */
  @Check(CheckType.NORMAL)
  public Object checkFunctionReturn(final Function function) {
    return null;
  }
  
  @Check(CheckType.NORMAL)
  public void checkVariableDefinition(final VariableStatement statement) {
    FunctionCallStatement _functionCall = statement.getAssignment().getAssignment().getFunctionCall();
    boolean _tripleNotEquals = (_functionCall != null);
    if (_tripleNotEquals) {
      this.error("Only simple assignments, not function calls, are permitted in variable definitions", 
        ProgramPackage.Literals.VARIABLE_STATEMENT__ASSIGNMENT);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkBufferRetention(final Function function) {
    final HashSet<Buffer> retained = CollectionLiterals.<Buffer>newHashSet();
    RetainAsStatement _retainedContents = function.getRetainedContents();
    boolean _tripleNotEquals = (_retainedContents != null);
    if (_tripleNotEquals) {
      final Consumer<AsStatement> _function = (AsStatement retain) -> {
        retained.add(retain.getBuffer());
      };
      function.getRetainedContents().getRetained().forEach(_function);
    }
    final Function1<RemoveStatement, Boolean> _function_1 = (RemoveStatement rmv) -> {
      boolean _xblockexpression = false;
      {
        final Sets.SetView<Buffer> intersection = Sets.<Buffer>intersection(IterableExtensions.<Buffer>toSet(rmv.getBuffers()), retained);
        int _size = intersection.size();
        _xblockexpression = (_size > 0);
      }
      return Boolean.valueOf(_xblockexpression);
    };
    Iterable<RemoveStatement> _filter = IterableExtensions.<RemoveStatement>filter(EcoreUtil2.<RemoveStatement>getAllContentsOfType(function, RemoveStatement.class), _function_1);
    for (final RemoveStatement remove : _filter) {
      EList<Buffer> _buffers = remove.getBuffers();
      for (final Buffer buffer : _buffers) {
        {
          final Function1<RequestStatement, Boolean> _function_2 = (RequestStatement statement) -> {
            Buffer _buffer = statement.getBuffer();
            return Boolean.valueOf((buffer == _buffer));
          };
          final RequestStatement open = IterableExtensions.<RequestStatement>findLast(Iterables.<RequestStatement>filter(this._validationUtilities.nodesOfTypeBefore(remove, RequestStatement.class), RequestStatement.class), _function_2);
          if ((open == null)) {
            String _name = buffer.getName();
            String _plus = ("Retained buffer " + _name);
            String _plus_1 = (_plus + " was removed.");
            this.warning(_plus_1, remove, 
              ProgramPackage.Literals.REMOVE_STATEMENT__BUFFERS);
          }
        }
      }
    }
  }
  
  /**
   * check open requests for leakage
   */
  @Check(CheckType.NORMAL)
  public void checkOpenRequestHasRemove(final RequestStatement request) {
    if (((request.getMapping() != null) || (request.getPatternReference() == null))) {
      return;
    }
    final Function1<RemoveStatement, Boolean> _function = (RemoveStatement rmv) -> {
      return Boolean.valueOf(rmv.getBuffers().contains(request.getBuffer()));
    };
    final Iterable<RemoveStatement> removes = IterableExtensions.<RemoveStatement>filter(Iterables.<RemoveStatement>filter(this._validationUtilities.nodesOfTypeAfter(request, RemoveStatement.class), RemoveStatement.class), _function);
    final Function function = EcoreUtil2.<Function>getContainerOfType(request, Function.class);
    final HashSet<Buffer> retained = CollectionLiterals.<Buffer>newHashSet();
    RetainAsStatement _retainedContents = function.getRetainedContents();
    boolean _tripleNotEquals = (_retainedContents != null);
    if (_tripleNotEquals) {
      final Consumer<AsStatement> _function_1 = (AsStatement retain) -> {
        retained.add(retain.getBuffer());
      };
      function.getRetainedContents().getRetained().forEach(_function_1);
    }
    final BufferDef bufferDesc = this._validationUtilities.bufferDefinition(request.getBuffer().getName(), request);
    boolean isEmpty = false;
    if ((bufferDesc != null)) {
      boolean _isPattern = this._validationUtilities.isPattern(request.getPatternReference().getName(), request);
      if (_isPattern) {
        Pattern _patternDefinition = this._validationUtilities.patternDefinition(request.getPatternReference().getName(), request);
        final Pattern pattern = ((Pattern) _patternDefinition);
        final RequestDef requestInfo = this._validationUtilities.getMatchingRequestInfo(bufferDesc, this._validationUtilities.getChunkType(request, pattern.getType()));
        if ((requestInfo != null)) {
          boolean _isWildcardResult = requestInfo.isWildcardResult();
          boolean _not = (!_isWildcardResult);
          if (_not) {
            ChunkType _resultType = requestInfo.getResultType();
            boolean _tripleEquals = (_resultType == null);
            isEmpty = _tripleEquals;
          }
        }
      } else {
      }
    }
    int _size = IterableExtensions.size(removes);
    boolean _equals = (_size == 0);
    if (_equals) {
      if (((!retained.contains(request.getBuffer())) && (!isEmpty))) {
        String _name = request.getBuffer().getName();
        String _plus = ("Request of " + _name);
        String _plus_1 = (_plus + " leaks. Advise adding remove statement");
        this.error(_plus_1, request, 
          ProgramPackage.Literals.REQUEST_STATEMENT__BUFFER);
      }
    } else {
      final Function1<RemoveStatement, Boolean> _function_2 = (RemoveStatement rmv) -> {
        return Boolean.valueOf(((rmv.eContainer() == request.eContainer()) || (rmv.eContainer() == function)));
      };
      final RemoveStatement siblingOrRoot = IterableExtensions.<RemoveStatement>findFirst(removes, _function_2);
      if ((((siblingOrRoot == null) && (!retained.contains(request.getBuffer()))) && (!isEmpty))) {
        String _name_1 = request.getBuffer().getName();
        String _plus_2 = ("Request of " + _name_1);
        String _plus_3 = (_plus_2 + " potentially leaks. Advise using terminal remove statement.");
        this.warning(_plus_3, request, ProgramPackage.Literals.REQUEST_STATEMENT__BUFFER);
      }
    }
  }
  
  /**
   * check for reserved names
   */
  @Check(CheckType.NORMAL)
  public void checkVariableDeclarations(final VariableStatement statement) {
    final VariableReference value = statement.getAssignment().getReference();
    final boolean isGoal = ((value.getBuffer() == null) || Objects.equal(value.getBuffer().getName(), "goal"));
    if (((value.getName() != null) && isGoal)) {
      if (((Objects.equal(value.getName(), "return") || Objects.equal(value.getName(), "parent")) || Objects.equal(value.getName(), "stage"))) {
        String _name = value.getName();
        String _plus = (_name + " is a reserved variable name");
        this.error(_plus, ProgramPackage.Literals.VARIABLE_STATEMENT__ASSIGNMENT);
      }
    }
  }
  
  /**
   * Check assignment side of the assignemnt statement
   */
  @Check(CheckType.NORMAL)
  public void checkAssignmentStatementAssignment(final AssignmentStatement statement) {
    final String name = statement.getAssignment().getValue().getName();
    if ((name == null)) {
      return;
    }
    if (((Objects.equal("null", name) || Objects.equal("true", name)) || Objects.equal("false", name))) {
      return;
    }
    Set slotsOf = ((Set) null);
    if (((statement.getAssignment().getBuffer() == null) || Objects.equal(statement.getAssignment().getBuffer().getName(), "goal"))) {
      final Function func = IterableExtensions.<Function>last(Iterables.<Function>filter(EcoreUtil2.getAllContainers(statement), Function.class));
      slotsOf = this._validationUtilities.slotsOf(func);
      boolean _contains = slotsOf.contains(name);
      boolean _not = (!_contains);
      if (_not) {
        boolean _isBuffer = this._validationUtilities.isBuffer(name, statement);
        boolean _not_1 = (!_isBuffer);
        if (_not_1) {
          boolean _isChunkType = this._validationUtilities.isChunkType(name, statement);
          boolean _not_2 = (!_isChunkType);
          if (_not_2) {
            boolean _isChunk = this._validationUtilities.isChunk(name, statement);
            boolean _not_3 = (!_isChunk);
            if (_not_3) {
              this.error(("Unknown chunk " + name), ProgramPackage.Literals.ASSIGNMENT_STATEMENT__ASSIGNMENT);
            }
          }
        }
      }
    } else {
      final HashMap<Buffer, ChunkType> bufferContents = this._validationUtilities.inferBufferContents(statement);
      final ChunkType chunkType = bufferContents.get(statement.getAssignment().getBuffer());
      if ((chunkType == null)) {
        this._validationUtilities.inferBufferContents(statement);
        this.error(("Could not infer chunktype to validate slot " + name), 
          ProgramPackage.Literals.ASSIGNMENT_STATEMENT__ASSIGNMENT);
        return;
      }
      slotsOf = this._validationUtilities.slotsOf(chunkType);
      boolean _contains_1 = slotsOf.contains(name);
      boolean _not_4 = (!_contains_1);
      if (_not_4) {
        String _name = chunkType.getName();
        String _plus = ((name + " is an unknown slot for ") + _name);
        String _plus_1 = (_plus + " known: ");
        String _plus_2 = (_plus_1 + slotsOf);
        this.error(_plus_2, 
          ProgramPackage.Literals.ASSIGNMENT_STATEMENT__ASSIGNMENT);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkSlotOfSimpleSlot(final SimpleSlot statement) {
    if ((statement.getName().startsWith(":") || statement.getName().startsWith("="))) {
      return;
    }
    final Iterable<EObject> containers = EcoreUtil2.getAllContainers(statement);
    final Chunks chunks = IterableExtensions.<Chunks>last(Iterables.<Chunks>filter(containers, Chunks.class));
    ChunkType chunkType = IterableExtensions.<ChunkType>last(Iterables.<ChunkType>filter(containers, ChunkType.class));
    if ((chunks != null)) {
      chunkType = chunks.getType();
    }
    final TreeSet<String> slotsOf = this._validationUtilities.slotsOf(chunkType);
    boolean _contains = slotsOf.contains(statement.getName());
    boolean _not = (!_contains);
    if (_not) {
      String _name = statement.getName();
      String _plus = (_name + " is an unknown slot for ");
      String _name_1 = chunkType.getName();
      String _plus_1 = (_plus + _name_1);
      String _plus_2 = (_plus_1 + " known: ");
      String _plus_3 = (_plus_2 + slotsOf);
      this.error(_plus_3, 
        ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkIDofSimpleSlot(final SimpleSlot statement) {
    final String name = statement.getValue().getName();
    if ((name == null)) {
      return;
    }
    if (((Objects.equal("null", name) || Objects.equal("true", name)) || Objects.equal("false", name))) {
      return;
    }
    boolean _startsWith = name.startsWith("=");
    if (_startsWith) {
      return;
    }
    boolean _isBuffer = this._validationUtilities.isBuffer(name, statement);
    boolean _not = (!_isBuffer);
    if (_not) {
      boolean _isChunkType = this._validationUtilities.isChunkType(name, statement);
      boolean _not_1 = (!_isChunkType);
      if (_not_1) {
        boolean _isChunk = this._validationUtilities.isChunk(name, statement);
        boolean _not_2 = (!_isChunk);
        if (_not_2) {
          this.error(("Unknown chunk " + name), ModelFragmentPackage.Literals.SIMPLE_SLOT__VALUE);
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkSlotOfConditionalSlot(final ConditionalSlot statement) {
    if ((statement.getName().startsWith(":") || statement.getName().startsWith("="))) {
      return;
    }
    final Pattern pattern = IterableExtensions.<Pattern>last(Iterables.<Pattern>filter(EcoreUtil2.getAllContainers(statement), Pattern.class));
    Set<String> slotsOf = Collections.<String>emptySet();
    boolean _isFunction = this._validationUtilities.isFunction(pattern.getType(), pattern);
    if (_isFunction) {
      EObject _object = this._validationUtilities.toObject(IterableExtensions.<IEObjectDescription>last(this._validationUtilities.functionTable(pattern).get(pattern.getType())), pattern.eResource().getResourceSet());
      final Function function = ((Function) _object);
      slotsOf = this._validationUtilities.slotsOf(function);
    } else {
      EObject _object_1 = this._validationUtilities.toObject(this._validationUtilities.findInTypeTable(statement, ModelFragmentPackage.Literals.CHUNK_TYPE, pattern.getType()), 
        pattern.eResource().getResourceSet());
      final ChunkType chunkType = ((ChunkType) _object_1);
      slotsOf = this._validationUtilities.slotsOf(chunkType);
    }
    boolean _contains = slotsOf.contains(statement.getName());
    boolean _not = (!_contains);
    if (_not) {
      String _name = statement.getName();
      String _plus = (_name + " is an unknown slot for ");
      String _type = pattern.getType();
      String _plus_1 = (_plus + _type);
      String _plus_2 = (_plus_1 + " known: ");
      String _plus_3 = (_plus_2 + slotsOf);
      this.error(_plus_3, 
        ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkIDofConditionalSlot(final ConditionalSlot statement) {
    final String name = statement.getValue().getName();
    if ((name == null)) {
      return;
    }
    if (((Objects.equal("null", name) || Objects.equal("true", name)) || Objects.equal("false", name))) {
      return;
    }
    boolean _startsWith = name.startsWith("=");
    if (_startsWith) {
      return;
    }
    boolean _isBuffer = this._validationUtilities.isBuffer(name, statement);
    boolean _not = (!_isBuffer);
    if (_not) {
      boolean _isChunkType = this._validationUtilities.isChunkType(name, statement);
      boolean _not_1 = (!_isChunkType);
      if (_not_1) {
        boolean _isChunk = this._validationUtilities.isChunk(name, statement);
        boolean _not_2 = (!_isChunk);
        if (_not_2) {
          this.error(("Unknown chunk " + name), ModelFragmentPackage.Literals.CONDITIONAL_SLOT__VALUE);
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkAssignmentStatementBufferPermissions(final AssignmentStatement statement) {
    Buffer _buffer = statement.getReference().getBuffer();
    boolean _tripleNotEquals = (_buffer != null);
    if (_tripleNotEquals) {
      final BufferDef def = this._validationUtilities.bufferDefinition(statement.getReference().getBuffer().getName(), statement);
      if ((def == null)) {
        String _name = statement.getReference().getBuffer().getName();
        String _plus = ("No buffer meta description could be found for " + _name);
        this.warning(_plus, 
          ProgramPackage.Literals.ASSIGNMENT_STATEMENT__REFERENCE);
      } else {
        boolean _isWritable = def.isWritable();
        boolean _not = (!_isWritable);
        if (_not) {
          String _name_1 = def.getName();
          String _plus_1 = (_name_1 + " is not writable");
          this.error(_plus_1, ProgramPackage.Literals.ASSIGNMENT_STATEMENT__REFERENCE);
        }
      }
    }
    Buffer _buffer_1 = statement.getAssignment().getBuffer();
    boolean _tripleNotEquals_1 = (_buffer_1 != null);
    if (_tripleNotEquals_1) {
      final BufferDef def_1 = this._validationUtilities.bufferDefinition(statement.getAssignment().getBuffer().getName(), statement);
      if ((def_1 == null)) {
        String _name_2 = statement.getAssignment().getBuffer().getName();
        String _plus_2 = ("No buffer meta description could be found for " + _name_2);
        this.warning(_plus_2, 
          ProgramPackage.Literals.ASSIGNMENT_STATEMENT__ASSIGNMENT);
      } else {
        if (((!def_1.isWritable()) && (!def_1.isReadable()))) {
          String _name_3 = def_1.getName();
          String _plus_3 = (_name_3 + " is not readable");
          this.error(_plus_3, ProgramPackage.Literals.ASSIGNMENT_STATEMENT__ASSIGNMENT);
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkRequestParameters(final RequestStatement statement) {
    boolean requiresCast = false;
    VariableReference _patternReference = statement.getPatternReference();
    boolean _tripleEquals = (_patternReference == null);
    if (_tripleEquals) {
      return;
    }
    Buffer _buffer = statement.getPatternReference().getBuffer();
    boolean _tripleEquals_1 = (_buffer == null);
    if (_tripleEquals_1) {
      final String name = statement.getPatternReference().getName();
      boolean _isBuffer = this._validationUtilities.isBuffer(name, statement);
      if (_isBuffer) {
        requiresCast = true;
      } else {
        boolean _isGoalSlot = this.isGoalSlot(name, statement);
        if (_isGoalSlot) {
          requiresCast = true;
        } else {
          boolean _isPattern = this._validationUtilities.isPattern(name, statement);
          if (_isPattern) {
            requiresCast = false;
          } else {
            boolean _isChunk = this._validationUtilities.isChunk(name, statement);
            if (_isChunk) {
              requiresCast = true;
            } else {
              this.error((("No pattern, buffer or slot named " + name) + " found."), 
                ProgramPackage.Literals.REQUEST_STATEMENT__PATTERN_REFERENCE, Diagnostic.LINKING_DIAGNOSTIC, name);
            }
          }
        }
      }
    } else {
      requiresCast = true;
      final HashMap<Buffer, ChunkType> contents = this._validationUtilities.inferBufferContents(statement);
      final ChunkType chunkType = contents.get(statement.getPatternReference().getBuffer());
      if ((chunkType == null)) {
        String _name = statement.getPatternReference().getBuffer().getName();
        String _plus = ("Could not infer chunktype for buffer " + _name);
        this.error(_plus, 
          ProgramPackage.Literals.REQUEST_STATEMENT__PATTERN_REFERENCE);
      } else {
        boolean _isValidSlotName = this.isValidSlotName(statement.getPatternReference().getName(), chunkType);
        boolean _not = (!_isValidSlotName);
        if (_not) {
          String _name_1 = statement.getPatternReference().getName();
          String _plus_1 = (_name_1 + " is not a valid slot of chunktype ");
          String _name_2 = chunkType.getName();
          String _plus_2 = (_plus_1 + _name_2);
          this.error(_plus_2, 
            ProgramPackage.Literals.REQUEST_STATEMENT__PATTERN_REFERENCE);
        }
      }
    }
    if ((requiresCast && (statement.getCast() == null))) {
      this.error("Request requires a cast as statement.", ProgramPackage.Literals.REQUEST_STATEMENT__PATTERN_REFERENCE);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkRequestTypes(final RequestStatement statement) {
    VariableReference _patternReference = statement.getPatternReference();
    boolean _tripleEquals = (_patternReference == null);
    if (_tripleEquals) {
      return;
    }
    Buffer _buffer = statement.getPatternReference().getBuffer();
    boolean _tripleNotEquals = (_buffer != null);
    if (_tripleNotEquals) {
      return;
    }
    final Pattern pattern = this._validationUtilities.patternDefinition(statement.getPatternReference().getName(), statement);
    if ((pattern == null)) {
      return;
    }
    final BufferDef def = this._validationUtilities.bufferDefinition(statement.getBuffer().getName(), statement);
    if ((def == null)) {
      String _name = statement.getBuffer().getName();
      String _plus = ("No buffer meta description could be found for " + _name);
      this.warning(_plus, 
        ProgramPackage.Literals.REQUEST_STATEMENT__BUFFER);
    } else {
      final Function1<RequestDef, Boolean> _function = (RequestDef request) -> {
        return Boolean.valueOf(request.isWildcardRequest());
      };
      final RequestDef wildCardRequest = IterableExtensions.<RequestDef>findFirst(def.getRequests(), _function);
      if ((wildCardRequest != null)) {
        return;
      }
      boolean anyValid = false;
      EList<RequestDef> _requests = def.getRequests();
      for (final RequestDef request : _requests) {
        boolean _isWildcardRequest = request.isWildcardRequest();
        boolean _not = (!_isWildcardRequest);
        if (_not) {
          final ChunkType refType = this._validationUtilities.getChunkType(statement, pattern.getType());
          boolean _isA = this._validationUtilities.isA(refType, request.getRequestType());
          if (_isA) {
            String _cast = statement.getCast();
            boolean _tripleNotEquals_1 = (_cast != null);
            if (_tripleNotEquals_1) {
              final ChunkType ct = this._validationUtilities.getChunkType(statement, statement.getCast());
              boolean _isA_1 = this._validationUtilities.isA(ct, request.getResultType());
              boolean _not_1 = (!_isA_1);
              if (_not_1) {
                String _name_1 = def.getName();
                String _plus_1 = (_name_1 + " results in ");
                String _name_2 = request.getResultType().getName();
                String _plus_2 = (_plus_1 + _name_2);
                String _plus_3 = (_plus_2 + " not ");
                String _cast_1 = statement.getCast();
                String _plus_4 = (_plus_3 + _cast_1);
                this.error(_plus_4, 
                  ProgramPackage.Literals.REQUEST_STATEMENT__CAST);
              }
            }
            anyValid = true;
            return;
          }
        }
      }
      if ((!anyValid)) {
        final Function1<RequestDef, String> _function_1 = (RequestDef req) -> {
          return req.getRequestType().getName();
        };
        final List<String> expectedTypes = ListExtensions.<RequestDef, String>map(def.getRequests(), _function_1);
        String _name_3 = def.getName();
        String _plus_5 = (_name_3 + " expects ");
        String _plus_6 = (_plus_5 + expectedTypes);
        String _plus_7 = (_plus_6 + " not ");
        String _type = pattern.getType();
        String _plus_8 = (_plus_7 + _type);
        this.error(_plus_8, 
          ProgramPackage.Literals.REQUEST_STATEMENT__BUFFER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkForLoopTypes(final ForLoopStatement statement) {
    final BufferDef def = this._validationUtilities.bufferDefinition(statement.getForBuffer().getName(), statement);
    if ((def == null)) {
      String _name = statement.getForBuffer().getName();
      String _plus = ("No buffer meta description could be found for " + _name);
      this.warning(_plus, 
        ProgramPackage.Literals.FOR_LOOP_STATEMENT__FOR_BUFFER);
    } else {
      final Function1<RequestDef, Boolean> _function = (RequestDef request) -> {
        return Boolean.valueOf(request.isWildcardRequest());
      };
      final RequestDef wildCardRequest = IterableExtensions.<RequestDef>findFirst(def.getRequests(), _function);
      if ((wildCardRequest != null)) {
        return;
      }
      EList<RequestDef> _requests = def.getRequests();
      for (final RequestDef request : _requests) {
        boolean _isWildcardRequest = request.isWildcardRequest();
        boolean _not = (!_isWildcardRequest);
        if (_not) {
          final ChunkType refType = this._validationUtilities.getChunkType(statement, statement.getInitial().getType());
          boolean _isA = this._validationUtilities.isA(refType, request.getRequestType());
          if (_isA) {
            return;
          }
        }
      }
      final Function1<RequestDef, String> _function_1 = (RequestDef req) -> {
        return req.getRequestType().getName();
      };
      final List<String> expectedTypes = ListExtensions.<RequestDef, String>map(def.getRequests(), _function_1);
      String _name_1 = def.getName();
      String _plus_1 = (_name_1 + " expects ");
      String _plus_2 = (_plus_1 + expectedTypes);
      String _plus_3 = (_plus_2 + " not ");
      String _type = statement.getInitial().getType();
      String _plus_4 = (_plus_3 + _type);
      this.error(_plus_4, 
        ProgramPackage.Literals.FOR_LOOP_STATEMENT__INITIAL);
      Pattern _subsequent = statement.getSubsequent();
      boolean _tripleNotEquals = (_subsequent != null);
      if (_tripleNotEquals) {
        EList<RequestDef> _requests_1 = def.getRequests();
        for (final RequestDef request_1 : _requests_1) {
          boolean _isWildcardRequest_1 = request_1.isWildcardRequest();
          boolean _not_1 = (!_isWildcardRequest_1);
          if (_not_1) {
            final ChunkType refType_1 = this._validationUtilities.getChunkType(statement, statement.getSubsequent().getType());
            boolean _isA_1 = this._validationUtilities.isA(refType_1, request_1.getRequestType());
            if (_isA_1) {
              return;
            }
          }
        }
        String _name_2 = def.getName();
        String _plus_5 = (_name_2 + " expects ");
        String _plus_6 = (_plus_5 + expectedTypes);
        String _plus_7 = (_plus_6 + " not ");
        String _type_1 = statement.getSubsequent().getType();
        String _plus_8 = (_plus_7 + _type_1);
        this.error(_plus_8, 
          ProgramPackage.Literals.FOR_LOOP_STATEMENT__SUBSEQUENT);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkAssignmentStatementReference(final AssignmentStatement statement) {
    final VariableReference value = statement.getReference();
    boolean isGoal = ((statement.getReference().getBuffer() == null) || Objects.equal(statement.getReference().getBuffer().getName(), "goal"));
    if (isGoal) {
      final Iterable<EObject> allContainers = EcoreUtil2.getAllContainers(statement);
      final TreeSet<String> slotsOf = this._validationUtilities.slotsOf(IterableExtensions.<Function>last(Iterables.<Function>filter(allContainers, Function.class)));
      FunctionCallStatement _last = IterableExtensions.<FunctionCallStatement>last(Iterables.<FunctionCallStatement>filter(allContainers, FunctionCallStatement.class));
      final boolean inFunctionCall = (_last != null);
      final Function1<String, Boolean> _function = (String slotName) -> {
        return Boolean.valueOf(slotName.equals(value.getName()));
      };
      final String first = IterableExtensions.<String>findFirst(slotsOf, _function);
      if (((first == null) && (!inFunctionCall))) {
        String _name = value.getName();
        String _plus = (_name + " is an unknown variable name.");
        this.error(_plus, ProgramPackage.Literals.ASSIGNMENT_STATEMENT__REFERENCE);
      }
    } else {
      final HashMap<Buffer, ChunkType> bufferContents = this._validationUtilities.inferBufferContents(statement);
      final ChunkType type = bufferContents.get(statement.getReference().getBuffer());
      if ((type == null)) {
        String _name_1 = statement.getReference().getBuffer().getName();
        String _plus_1 = ("No mapping-free request on " + _name_1);
        this.error(_plus_1, 
          ProgramPackage.Literals.ASSIGNMENT_STATEMENT__REFERENCE);
      } else {
        boolean _isValidSlotName = this.isValidSlotName(statement.getReference().getName(), type);
        boolean _not = (!_isValidSlotName);
        if (_not) {
          String _name_2 = statement.getReference().getName();
          String _plus_2 = (_name_2 + " is not a valid slot of ");
          String _name_3 = type.getName();
          String _plus_3 = (_plus_2 + _name_3);
          this.error(_plus_3, 
            ProgramPackage.Literals.ASSIGNMENT_STATEMENT__REFERENCE);
        }
      }
    }
    FunctionCallStatement _functionCall = statement.getAssignment().getFunctionCall();
    boolean _tripleNotEquals = (_functionCall != null);
    if (_tripleNotEquals) {
      return;
    }
  }
  
  @Check(CheckType.NORMAL)
  public Object checkFunctionCall(final FunctionCallStatement functionCall) {
    return null;
  }
  
  protected boolean isGoalSlot(final String slotName, final EObject inTree) {
    final Function function = EcoreUtil2.<Function>getContainerOfType(inTree, Function.class);
    final ChunkType chunkType = this._validationUtilities.getChunkType(inTree, function.getName());
    return this.isValidSlotName(slotName, chunkType);
  }
  
  protected boolean isValidSlotName(final String slotName, final ChunkType chunkType) {
    ChunkType ct = chunkType;
    while ((ct != null)) {
      {
        final Function1<SimpleSlot, Boolean> _function = (SimpleSlot slot) -> {
          String _name = slot.getName();
          return Boolean.valueOf(Objects.equal(_name, slotName));
        };
        SimpleSlot _last = IterableExtensions.<SimpleSlot>last(IterableExtensions.<SimpleSlot>filter(ct.getSlots(), _function));
        final boolean exists = (_last != null);
        if (exists) {
          return true;
        }
        ct = ct.getSuperType();
      }
    }
    return false;
  }
  
  protected void checkBindingOfGoal(final Collection<? extends BufferPattern> bufferPatterns, final EReference errorLiteral) {
    final HashMap<Buffer, ChunkType> contents = this._validationUtilities.inferBufferContents(IterableExtensions.last(bufferPatterns));
    final Consumer<BufferPattern> _function = (BufferPattern bP) -> {
      String _name = bP.getPattern().getName();
      boolean _tripleNotEquals = (_name != null);
      if (_tripleNotEquals) {
        String _name_1 = bP.getBuffer().getName();
        boolean _equals = Objects.equal(_name_1, "goal");
        if (_equals) {
          final Function function = IterableExtensions.<Function>last(Iterables.<Function>filter(EcoreUtil2.getAllContainers(bP), Function.class));
          String _type = bP.getPattern().getType();
          String _name_2 = function.getName();
          boolean _notEquals = (!Objects.equal(_type, _name_2));
          if (_notEquals) {
            String _name_3 = function.getName();
            String _plus = ("Goal pattern type should match against " + _name_3);
            this.error(_plus, errorLiteral);
          }
        } else {
          final ChunkType type = contents.get(bP.getBuffer());
          if ((type == null)) {
            this.error("Could not infer chunktype from open request", errorLiteral);
          }
        }
      }
    };
    bufferPatterns.forEach(_function);
  }
  
  @Check(CheckType.NORMAL)
  public void checkIfBindings(final IfThenElseStatement statement) {
    this.checkBindingOfGoal(statement.getBindings().getBindings(), ProgramPackage.Literals.IF_THEN_ELSE_STATEMENT__BINDINGS);
  }
  
  @Check(CheckType.NORMAL)
  public void checkWhileDoBindings(final WhileDoStatement statement) {
    this.checkBindingOfGoal(statement.getWhile().getBindings().getBindings(), ProgramPackage.Literals.WHILE_DO_STATEMENT__WHILE);
  }
  
  @Check(CheckType.NORMAL)
  public void checkDoWhileBindings(final DoWhileStatement statement) {
    this.checkBindingOfGoal(statement.getWhile().getBindings().getBindings(), ProgramPackage.Literals.DO_WHILE_STATEMENT__WHILE);
  }
  
  @Check(CheckType.NORMAL)
  public void checkRepeatUntilBindings(final RepeatUntilStatement statement) {
    this.checkBindingOfGoal(statement.getUntil().getBindings().getBindings(), ProgramPackage.Literals.REPEAT_UNTIL_STATEMENT__UNTIL);
  }
  
  @Check(CheckType.NORMAL)
  public void checkUntilRepeatBindings(final UntilRepeatStatement statement) {
    this.checkBindingOfGoal(statement.getUntil().getBindings().getBindings(), ProgramPackage.Literals.UNTIL_REPEAT_STATEMENT__UNTIL);
  }
  
  @Check(CheckType.NORMAL)
  public void checkMatchStatementBindings(final MatchStatement statement) {
    final Consumer<CaseStatement> _function = (CaseStatement caseNode) -> {
      this.checkBindingOfGoal(caseNode.getBindings().getBindings(), ProgramPackage.Literals.MATCH_STATEMENT__CASES);
    };
    statement.getCases().forEach(_function);
  }
  
  @Check(CheckType.NORMAL)
  public void checkRequest(final RequestStatement request) {
    boolean hasError = true;
    final BufferDef bufferDesc = this._validationUtilities.bufferDefinition(request.getBuffer().getName(), request);
    if ((bufferDesc != null)) {
      hasError = bufferDesc.isError();
    }
    Handler _handler = request.getHandler();
    boolean _tripleEquals = (_handler == null);
    if (_tripleEquals) {
      boolean anyHandler = false;
      final Function1<RequestStatement, Boolean> _function = (RequestStatement statement) -> {
        return Boolean.valueOf(((request != statement) && (request.getBuffer() == statement.getBuffer())));
      };
      Iterable<RequestStatement> _filter = IterableExtensions.<RequestStatement>filter(EcoreUtil2.<RequestStatement>getAllContentsOfType(request.eContainer(), RequestStatement.class), _function);
      for (final RequestStatement statement : _filter) {
        Handler _handler_1 = statement.getHandler();
        boolean _tripleNotEquals = (_handler_1 != null);
        if (_tripleNotEquals) {
          anyHandler = true;
        }
      }
      if (((!anyHandler) && hasError)) {
        this.warning("An error handler should be specified either in this or a subsequent request call", 
          ProgramPackage.Literals.REQUEST_STATEMENT__BUFFER);
      }
    }
    if ((hasError && (request.getPatternReference() != null))) {
      Mapping _mapping = request.getMapping();
      boolean _tripleEquals_1 = (_mapping == null);
      if (_tripleEquals_1) {
        boolean emptyIsValid = false;
        ChunkType chunkType = ((ChunkType) null);
        String _cast = request.getCast();
        boolean _tripleNotEquals_1 = (_cast != null);
        if (_tripleNotEquals_1) {
          chunkType = this._validationUtilities.getChunkType(request, request.getCast());
        } else {
          final Pattern pattern = this._validationUtilities.patternDefinition(request.getPatternReference().getName(), request);
          chunkType = this._validationUtilities.getChunkType(request, pattern.getType());
        }
        if (((chunkType != null) && (bufferDesc != null))) {
          final RequestDef requestInfo = this._validationUtilities.getMatchingRequestInfo(bufferDesc, chunkType);
          if ((requestInfo != null)) {
            ChunkType _resultType = requestInfo.getResultType();
            boolean _tripleEquals_2 = (_resultType == null);
            emptyIsValid = _tripleEquals_2;
          }
        }
        if ((!emptyIsValid)) {
          this.info("Good form recommends using the mapping block to grab a reference and release the resource", 
            ProgramPackage.Literals.REQUEST_STATEMENT__BUFFER);
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkRequestPattern(final RequestStatement request) {
    VariableReference _patternReference = request.getPatternReference();
    boolean _tripleEquals = (_patternReference == null);
    if (_tripleEquals) {
      return;
    }
    Buffer _buffer = request.getPatternReference().getBuffer();
    boolean _tripleNotEquals = (_buffer != null);
    if (_tripleNotEquals) {
      return;
    }
    List<BufferPattern> bindings = Collections.<BufferPattern>emptyList();
    Bindings _bindings = request.getBindings();
    boolean _tripleNotEquals_1 = (_bindings != null);
    if (_tripleNotEquals_1) {
      bindings = request.getBindings().getBindings();
    }
    final Pattern pattern = this._validationUtilities.patternDefinition(request.getPatternReference().getName(), request);
    this.checkVariablesInPattern(pattern, bindings, ProgramPackage.Literals.REQUEST_STATEMENT__PATTERN_REFERENCE);
    this.checkBindingOfGoal(request.getBindings().getBindings(), ProgramPackage.Literals.REQUEST_STATEMENT__BINDINGS);
  }
  
  @Check(CheckType.NORMAL)
  public void checkForLoopPatterns(final ForLoopStatement loopStatement) {
    List<BufferPattern> bindings = Collections.<BufferPattern>emptyList();
    Bindings _initialBindings = loopStatement.getInitialBindings();
    boolean _tripleNotEquals = (_initialBindings != null);
    if (_tripleNotEquals) {
      bindings = loopStatement.getInitialBindings().getBindings();
    }
    this.checkVariablesInPattern(loopStatement.getInitial(), bindings, ProgramPackage.Literals.FOR_LOOP_STATEMENT__INITIAL);
    this.checkBindingOfGoal(bindings, ProgramPackage.Literals.FOR_LOOP_STATEMENT__INITIAL_BINDINGS);
    bindings = Collections.<BufferPattern>emptyList();
    Bindings _subsequentBindings = loopStatement.getSubsequentBindings();
    boolean _tripleNotEquals_1 = (_subsequentBindings != null);
    if (_tripleNotEquals_1) {
      bindings = loopStatement.getSubsequentBindings().getBindings();
    }
    this.checkVariablesInPattern(loopStatement.getSubsequent(), bindings, ProgramPackage.Literals.FOR_LOOP_STATEMENT__SUBSEQUENT);
    this.checkBindingOfGoal(bindings, ProgramPackage.Literals.FOR_LOOP_STATEMENT__SUBSEQUENT_BINDINGS);
  }
  
  @Check(CheckType.FAST)
  public void checkPatternType(final Pattern pattern) {
    boolean valid = this._validationUtilities.isFunction(pattern.getType(), pattern);
    if ((!valid)) {
      valid = this._validationUtilities.isChunkType(pattern.getType(), pattern);
    }
    if ((!valid)) {
      this.error("Pattern isa must be a valid chunktype or function", pattern, ProgramPackage.Literals.PATTERN__TYPE);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkPatternName(final Pattern pattern) {
    final LinkedListMultimap<String, IEObjectDescription> table = this._validationUtilities.patternTable(pattern);
    int _size = table.get(pattern.getName()).size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("Patterns must be uniquely named", ProgramPackage.Literals.PATTERN__NAME);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkFunctionName(final Function function) {
    final LinkedListMultimap<String, IEObjectDescription> table = this._validationUtilities.functionTable(function);
    int _size = table.get(function.getName()).size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      this.error("Functions must be uniquely named", ProgramPackage.Literals.FUNCTION__NAME);
    }
  }
  
  /**
   * none should be function calls
   */
  @Check(CheckType.NORMAL)
  public void checkRequestAssignments(final RequestStatement statement) {
    Mapping _mapping = statement.getMapping();
    EList<AssignmentStatement> _assignments = null;
    if (_mapping!=null) {
      _assignments=_mapping.getAssignments();
    }
    final Consumer<AssignmentStatement> _function = (AssignmentStatement ass) -> {
      FunctionCallStatement _functionCall = ass.getAssignment().getFunctionCall();
      boolean _tripleNotEquals = (_functionCall != null);
      if (_tripleNotEquals) {
        this.error("Only simple assignments, not function calls, are permitted in handlers.", ass, 
          ProgramPackage.Literals.ASSIGNMENT_STATEMENT__ASSIGNMENT);
      }
    };
    _assignments.forEach(_function);
  }
  
  @Check(CheckType.NORMAL)
  public void checkRequestForForce(final RequestStatement statement) {
    if (((statement.getPatternReference() == null) || statement.isForced())) {
      return;
    }
    final HashMap<Buffer, ChunkType> contents = this._validationUtilities.inferBufferContents(statement);
    boolean _containsKey = contents.containsKey(statement.getBuffer());
    if (_containsKey) {
      final Function1<RemoveStatement, Boolean> _function = (RemoveStatement remove) -> {
        return Boolean.valueOf(remove.getBuffers().contains(statement.getBuffer()));
      };
      final RemoveStatement priorRemove = IterableExtensions.<RemoveStatement>findLast(Iterables.<RemoveStatement>filter(this._validationUtilities.nodesOfTypeBefore(statement, RemoveStatement.class), RemoveStatement.class), _function);
      if ((priorRemove == null)) {
        String _name = statement.getBuffer().getName();
        String _plus = (_name + " may not be empty. Request is likely to block on contents. Recommend using force.");
        this.warning(_plus, 
          ProgramPackage.Literals.REQUEST_STATEMENT__BUFFER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkForLoopForForce(final ForLoopStatement statement) {
    boolean _isForced = statement.isForced();
    if (_isForced) {
      return;
    }
    final HashMap<Buffer, ChunkType> contents = this._validationUtilities.inferBufferContents(statement);
    boolean _containsKey = contents.containsKey(statement.getForBuffer());
    if (_containsKey) {
      final Function1<RemoveStatement, Boolean> _function = (RemoveStatement remove) -> {
        return Boolean.valueOf(remove.getBuffers().contains(statement.getForBuffer()));
      };
      final RemoveStatement priorRemove = IterableExtensions.<RemoveStatement>findLast(Iterables.<RemoveStatement>filter(this._validationUtilities.nodesOfTypeBefore(statement, RemoveStatement.class), RemoveStatement.class), _function);
      if ((priorRemove == null)) {
        String _name = statement.getForBuffer().getName();
        String _plus = (_name + 
          " may not be empty. Request is likely to block on contents. Recommend using force.");
        this.warning(_plus, 
          ProgramPackage.Literals.FOR_LOOP_STATEMENT__FOR_BUFFER);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkIrrelevantRemove(final RemoveStatement remove) {
    final HashMap<Buffer, ChunkType> contents = this._validationUtilities.inferBufferContents(remove);
    EList<Buffer> _buffers = remove.getBuffers();
    for (final Buffer buffer : _buffers) {
      boolean _containsKey = contents.containsKey(buffer);
      boolean _not = (!_containsKey);
      if (_not) {
        this.warning("Contents of buffer are likely empty.", ProgramPackage.Literals.REMOVE_STATEMENT__BUFFERS);
      }
    }
  }
}
